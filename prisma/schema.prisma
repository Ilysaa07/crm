generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                String           @id @default(cuid())
  email             String           @unique
  password          String
  fullName          String
  address           String?
  gender            Gender?
  nikKtp            String?          @unique
  phoneNumber       String?
  bankAccountNumber String?
  ewalletNumber     String?
  profilePicture    String?
  role              Role             @default(EMPLOYEE)
  status            UserStatus       @default(PENDING)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  notifications     Notification[]
  taskSubmissions   TaskSubmission[]
  assignedTasks     Task[]           @relation("TaskAssignee")
  createdTasks      Task[]           @relation("TaskCreator")
  transactions      Transaction[]
  // Chat relationships
  conversationParticipants ConversationParticipant[]
  sentMessages             Message[]
  messageReads             MessageRead[]
  messageDeletes           MessageDelete[]
  conversationDeletes      ConversationDelete[]

  // Attendance & Leave relations
  attendance              Attendance[]
  leaveRequests           LeaveRequest[]        @relation("LeaveRequestUser")
  decidedLeaveRequests    LeaveRequest[]        @relation("LeaveRequestDecider")
  taskFeedbacks           TaskFeedback[]

  @@map("users")
}

model Task {
  id                String             @id @default(cuid())
  title             String
  description       String
  dueDate           DateTime?
  status            TaskStatus         @default(NOT_STARTED)
  assignment        TaskAssignmentType
  createdById       String
  assigneeId        String?
  validationMessage String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  notifications     Notification[]
  submissions       TaskSubmission[]
  feedbacks         TaskFeedback[]
  assignee          User?              @relation("TaskAssignee", fields: [assigneeId], references: [id])
  createdBy         User               @relation("TaskCreator", fields: [createdById], references: [id], onDelete: Cascade)

  @@index([assigneeId], map: "tasks_assigneeId_fkey")
  @@index([createdById], map: "tasks_createdById_fkey")
  @@map("tasks")
}

model TaskSubmission {
  id           String   @id @default(cuid())
  taskId       String
  userId       String
  description  String?
  documentUrl  String?
  documentName String?
  documentSize Int?
  submittedAt  DateTime @default(now())
  updatedAt    DateTime @updatedAt
  task         Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskId, userId])
  @@index([userId], map: "task_submissions_userId_fkey")
  @@map("task_submissions")
}

model Transaction {
  id          String              @id @default(cuid())
  type        TransactionType
  category    TransactionCategory
  amount      Decimal             @db.Decimal(15, 2)
  description String
  date        DateTime
  createdById String
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  createdBy   User                @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@index([createdById], map: "transactions_createdById_fkey")
  @@map("transactions")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  taskId    String?
  title     String
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  task      Task?    @relation(fields: [taskId], references: [id])
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([taskId], map: "notifications_taskId_fkey")
  @@index([userId], map: "notifications_userId_fkey")
  @@map("notifications")
}

// Attendance & Leave Management Models
model Attendance {
  id                String            @id @default(cuid())
  userId            String
  checkInAt         DateTime?
  checkOutAt        DateTime?
  workMode          WorkMode          @default(WFO)
  method            AttendanceMethod
  ipAddress         String?
  
  // GPS coordinates for check-in
  latitudeIn        Float?
  longitudeIn       Float?
  
  // GPS coordinates for check-out
  latitudeOut       Float?
  longitudeOut      Float?
  
  // Proof of work for WFH
  proofOfWorkUrl    String?
  proofOfWorkName   String?
  
  status            AttendanceStatus
  notes             String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "attendance_userId_idx")
  @@index([checkInAt], map: "attendance_checkInAt_idx")
  @@index([workMode], map: "attendance_workMode_idx")
  @@map("attendance")
}

model AttendanceConfig {
  id               String   @id @default(cuid())
  workStartHour    Int      @default(9)
  workEndHour      Int      @default(17)
  
  // Office location coordinates
  officeLat        Float?
  officeLng        Float?
  radiusMeters     Int      @default(200)
  
  // Geofencing settings
  useGeofence      Boolean  @default(false)
  enforceGeofence  Boolean  @default(false)
  
  // WFH settings
  requireProofOfWork Boolean @default(true)
  allowWFH          Boolean  @default(true)
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@map("attendance_config")
}

model LeaveRequest {
  id           String       @id @default(cuid())
  userId       String
  type         LeaveType
  startDate    DateTime
  endDate      DateTime
  reason       String
  status       LeaveStatus  @default(PENDING)
  decidedById  String?
  decidedAt    DateTime?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  user         User         @relation("LeaveRequestUser", fields: [userId], references: [id], onDelete: Cascade)
  decidedBy    User?        @relation("LeaveRequestDecider", fields: [decidedById], references: [id])

  @@index([userId], map: "leave_userId_idx")
  @@index([status], map: "leave_status_idx")
  @@map("leave_requests")
}

model TaskFeedback {
  id        String   @id @default(cuid())
  taskId    String
  userId    String
  message   String   @db.Text
  createdAt DateTime @default(now())
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([taskId], map: "task_feedback_taskId_idx")
  @@index([userId], map: "task_feedback_userId_idx")
  @@map("task_feedback")
}

// Chat System Models
model Conversation {
  id          String                    @id @default(cuid())
  name        String?                   // For group chats
  type        ConversationType          @default(DIRECT)
  isArchived  Boolean                   @default(false)
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt
  messages    Message[]
  participants ConversationParticipant[]
  deletedForUsers ConversationDelete[]

  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(MEMBER)
  joinedAt       DateTime     @default(now())
  leftAt         DateTime?
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId], map: "conversation_participants_conversationId_fkey")
  @@index([userId], map: "conversation_participants_userId_fkey")
  @@map("conversation_participants")
}

model Message {
  id             String              @id @default(cuid())
  conversationId String
  senderId       String
  content        String              @db.Text
  messageType    MessageType         @default(TEXT)
  isEdited       Boolean             @default(false)
  isDeleted      Boolean             @default(false)
  deletedAt      DateTime?
  deletedBy      String?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  conversation   Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User                @relation(fields: [senderId], references: [id], onDelete: Cascade)
  attachments    MessageAttachment[]
  readReceipts   MessageRead[]
  deletedForUsers MessageDelete[]

  @@index([conversationId], map: "messages_conversationId_fkey")
  @@index([senderId], map: "messages_senderId_fkey")
  @@index([createdAt], map: "messages_createdAt_fkey")
  @@map("messages")
}

model MessageAttachment {
  id        String   @id @default(cuid())
  messageId String
  fileName  String
  fileUrl   String
  fileSize  Int
  fileType  String
  createdAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId], map: "message_attachments_messageId_fkey")
  @@map("message_attachments")
}

model MessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId], map: "message_reads_messageId_fkey")
  @@index([userId], map: "message_reads_userId_fkey")
  @@map("message_reads")
}

model MessageDelete {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  deletedAt DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId], map: "message_deletes_messageId_fkey")
  @@index([userId], map: "message_deletes_userId_fkey")
  @@map("message_deletes")
}

model ConversationDelete {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  deletedAt      DateTime @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId], map: "conversation_deletes_conversationId_fkey")
  @@index([userId], map: "conversation_deletes_userId_fkey")
  @@map("conversation_deletes")
}


enum Role {
  ADMIN
  EMPLOYEE
  CLIENT
}

enum Gender {
  MALE
  FEMALE
}

enum UserStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TaskStatus {
  NOT_STARTED
  IN_PROGRESS
  PENDING_VALIDATION
  COMPLETED
}

enum TaskAssignmentType {
  SPECIFIC
  ALL_EMPLOYEES
}

enum TransactionType {
  INCOME
  EXPENSE
}

enum TransactionCategory {
  SALARY
  BONUS
  COMMISSION
  OTHER_INCOME
  OFFICE_SUPPLIES
  UTILITIES
  RENT
  MARKETING
  TRAVEL
  MEALS
  EQUIPMENT
  SOFTWARE
  TRAINING
  OTHER_EXPENSE
}

enum ConversationType {
  DIRECT
  GROUP
}

enum ParticipantRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum MessageType {
  TEXT
  FILE
  IMAGE
  AUDIO
  VIDEO
  DELETED
}

enum AttendanceMethod {
  GPS
  IP
  MANUAL
}

enum AttendanceStatus {
  ONTIME
  LATE
  ABSENT
  EARLY_LEAVE
}

enum LeaveType {
  ANNUAL
  SICK
  PERMIT
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
}

enum WorkMode {
  WFO
  WFH
}
